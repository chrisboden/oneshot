#!/bin/bash

# export_as_screenshot_from_markdown - Convert Markdown file to PNG screenshot via HTML rendering
# Usage: ./export_as_screenshot_from_markdown <path_to_markdown_file> [--visible-only]

set -e  # Exit on any error

# Default to full page screenshot
VISIBLE_ONLY=false

# Check if argument is provided
if [ $# -eq 0 ]; then
    echo "Usage: $0 <path_to_markdown_file> [--visible-only]"
    echo "Example: $0 /path/to/document.md"
    echo "         $0 ./README.md --visible-only"
    echo ""
    echo "Options:"
    echo "  --visible-only    Capture only the visible viewport (100vh)"
    echo "  (default)         Capture the entire page length"
    exit 1
fi

MARKDOWN_FILE="$1"

# Check for visible-only flag
if [ "$2" = "--visible-only" ]; then
    VISIBLE_ONLY=true
fi

# Check if markdown file exists
if [ ! -f "$MARKDOWN_FILE" ]; then
    echo "Error: Markdown file '$MARKDOWN_FILE' not found"
    exit 1
fi

# Get absolute path of markdown file
MARKDOWN_ABS_PATH=$(realpath "$MARKDOWN_FILE")

# Get directory and filename without extension
MARKDOWN_DIR=$(dirname "$MARKDOWN_ABS_PATH")
MARKDOWN_BASENAME=$(basename "$MARKDOWN_FILE" .md)

# Temporary HTML file path
HTML_TEMP_PATH="$MARKDOWN_DIR/$MARKDOWN_BASENAME-temp.html"

# Output PNG path
if [ "$VISIBLE_ONLY" = true ]; then
    PNG_PATH="$MARKDOWN_DIR/$MARKDOWN_BASENAME-viewport.png"
else
    PNG_PATH="$MARKDOWN_DIR/$MARKDOWN_BASENAME-fullpage.png"
fi

echo "üìù Converting Markdown to PNG screenshot..."
echo "üìÑ Input:  $MARKDOWN_ABS_PATH"
echo "üñºÔ∏è  Output: $PNG_PATH"
if [ "$VISIBLE_ONLY" = true ]; then
    echo "üìê Mode:   Visible viewport only (100vh)"
else
    echo "üìê Mode:   Full page length (default)"
fi

# Ensure marked (markdown parser) is installed
if [ ! -d "node_modules/marked" ]; then
    echo "‚ö†Ô∏è  Installing markdown parser..."
    npm install marked --silent
fi

# Ensure puppeteer is installed
if [ ! -d "node_modules/puppeteer" ]; then
    echo "‚ö†Ô∏è  Installing Puppeteer..."
    npm install puppeteer --silent
fi

echo "üîÑ Converting Markdown to HTML..."

# Create the markdown to HTML converter script (same as PDF version)
cat > markdown_to_html_temp.js << 'EOF'
const fs = require('fs');

async function convertMarkdownToHTML() {
    const markdownPath = process.argv[2];
    const htmlPath = process.argv[3];
    
    if (!fs.existsSync(markdownPath)) {
        console.error('‚ùå Error: Markdown file not found:', markdownPath);
        process.exit(1);
    }
    
    try {
        // Dynamic import for marked ES module
        const { marked } = await import('marked');
        
        // Read markdown file
        let markdownContent = fs.readFileSync(markdownPath, 'utf8');
        
        // Strip YAML frontmatter if present
        if (markdownContent.startsWith('---')) {
            const lines = markdownContent.split('\n');
            let frontmatterEnd = -1;
            
            // Find the end of frontmatter (second ---)
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '---') {
                    frontmatterEnd = i;
                    break;
                }
            }
            
            if (frontmatterEnd > 0) {
                // Remove frontmatter and any leading empty lines
                markdownContent = lines.slice(frontmatterEnd + 1).join('\n');
                // Remove leading empty lines
                markdownContent = markdownContent.replace(/^\s*\n+/, '');
                console.log('‚úÇÔ∏è  Stripped YAML frontmatter from markdown');
            }
        }
        
        // Configure marked options for better rendering
        marked.setOptions({
            breaks: true,
            gfm: true,
            headerIds: true,
            mangle: false
        });
        
        // Convert markdown to HTML
        const htmlContent = marked(markdownContent);
        
        // Create a complete HTML document with styling
        const fullHTML = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown Document</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
            background: white;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 2em;
            margin-bottom: 1em;
            font-weight: 600;
            line-height: 1.25;
        }
        
        h1 {
            font-size: 2em;
            border-bottom: 1px solid #eaecef;
            padding-bottom: 0.3em;
        }
        
        h2 {
            font-size: 1.5em;
            border-bottom: 1px solid #eaecef;
            padding-bottom: 0.3em;
        }
        
        h3 { font-size: 1.25em; }
        h4 { font-size: 1em; }
        h5 { font-size: 0.875em; }
        h6 { font-size: 0.85em; color: #6a737d; }
        
        p {
            margin-bottom: 16px;
        }
        
        blockquote {
            padding: 0 1em;
            color: #6a737d;
            border-left: 0.25em solid #dfe2e5;
            margin: 0 0 16px 0;
        }
        
        ul, ol {
            padding-left: 2em;
            margin-bottom: 16px;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
            margin-bottom: 16px;
        }
        
        pre code {
            background: transparent;
            padding: 0;
        }
        
        table {
            border-spacing: 0;
            border-collapse: collapse;
            margin-bottom: 16px;
            width: 100%;
        }
        
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #dfe2e5;
        }
        
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        
        img {
            max-width: 100%;
            height: auto;
        }
        
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #e1e4e8;
            border: 0;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        @media print {
            body {
                margin: 0;
                padding: 20px;
            }
        }
    </style>
</head>
<body>
${htmlContent}
</body>
</html>`;
        
        // Write HTML file
        fs.writeFileSync(htmlPath, fullHTML, 'utf8');
        
        console.log('‚úÖ HTML generated successfully');
        
    } catch (error) {
        console.error('‚ùå Error converting markdown:', error.message);
        process.exit(1);
    }
}

convertMarkdownToHTML().catch(error => {
    console.error('‚ùå Fatal error:', error.message);
    process.exit(1);
});
EOF

# Convert markdown to HTML
node markdown_to_html_temp.js "$MARKDOWN_ABS_PATH" "$HTML_TEMP_PATH"

# Clean up the markdown converter script
rm markdown_to_html_temp.js

echo "üîÑ Converting HTML to PNG screenshot..."

# Create the screenshot generator script
cat > screenshot_generator_temp.js << 'EOF'
const puppeteer = require('puppeteer');
const path = require('path');
const fs = require('fs');

async function generateScreenshot() {
    const htmlPath = process.argv[2];
    const pngPath = process.argv[3];
    const visibleOnly = process.argv[4] === 'true';
    
    if (!fs.existsSync(htmlPath)) {
        console.error('‚ùå Error: HTML file not found:', htmlPath);
        process.exit(1);
    }
    
    console.log('üöÄ Starting screenshot generation...');
    
    let browser;
    try {
        browser = await puppeteer.launch({
            headless: 'new',
            args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage']
        });
        
        const page = await browser.newPage();
        
        // Set viewport size
        await page.setViewport({
            width: 1920,
            height: 1080,
            deviceScaleFactor: 1
        });
        
        // Load the HTML file
        const fileUrl = `file://${htmlPath}`;
        console.log(`üìñ Loading: ${fileUrl}`);
        
        await page.goto(fileUrl, {
            waitUntil: 'networkidle0',
            timeout: 30000
        });
        
        // Wait for dynamic content and fonts to load
        console.log('‚è≥ Waiting for content to load...');
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        console.log('üì∏ Taking screenshot...');
        
        // Take screenshot with appropriate settings
        const screenshotOptions = {
            path: pngPath,
            type: 'png'
        };
        
        if (visibleOnly) {
            // Capture only the visible viewport
            screenshotOptions.clip = {
                x: 0,
                y: 0,
                width: 1920,
                height: 1080
            };
            console.log('üìê Capturing visible viewport only...');
        } else {
            // Capture the full page
            screenshotOptions.fullPage = true;
            console.log('üìê Capturing full page length...');
        }
        
        await page.screenshot(screenshotOptions);
        
        // Get file size
        const stats = fs.statSync(pngPath);
        const fileSizeInMB = (stats.size / 1024 / 1024).toFixed(2);
        
        console.log(`‚úÖ Screenshot generated successfully!`);
        console.log(`üìä File size: ${fileSizeInMB} MB`);
        
    } catch (error) {
        console.error('‚ùå Error generating screenshot:', error.message);
        process.exit(1);
    } finally {
        if (browser) {
            await browser.close();
        }
    }
}

// Handle process termination gracefully
process.on('SIGINT', () => {
    console.log('\nüõë Process interrupted');
    process.exit(1);
});

process.on('SIGTERM', () => {
    console.log('\nüõë Process terminated');
    process.exit(1);
});

generateScreenshot().catch(error => {
    console.error('‚ùå Fatal error:', error.message);
    process.exit(1);
});
EOF

# Run the screenshot generation
echo "üîß Running screenshot conversion..."
node screenshot_generator_temp.js "$HTML_TEMP_PATH" "$PNG_PATH" "$VISIBLE_ONLY"

# Clean up temporary files
rm screenshot_generator_temp.js
rm "$HTML_TEMP_PATH"

# Check if PNG was created successfully
if [ -f "$PNG_PATH" ]; then
    echo "üéâ Success! Screenshot created at: $PNG_PATH"
    
    # Open the PNG
    echo "üñºÔ∏è  Opening screenshot..."
    if command -v open > /dev/null 2>&1; then
        # macOS
        open "$PNG_PATH"
    elif command -v xdg-open > /dev/null 2>&1; then
        # Linux
        xdg-open "$PNG_PATH"
    elif command -v start > /dev/null 2>&1; then
        # Windows (Git Bash/WSL)
        start "$PNG_PATH"
    else
        echo "üìã Screenshot ready at: $PNG_PATH"
        echo "   (Unable to auto-open - please open manually)"
    fi
else
    echo "‚ùå Error: Screenshot was not created"
    exit 1
fi

echo "‚ú® Done!" 